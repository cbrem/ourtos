\documentclass{article}

\usepackage{color}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{fullpage}


\sloppy
\definecolor{lightgray}{gray}{0.5}
\setlength{\parindent}{0pt}
\renewcommand{\arraystretch}{1.2}

\newcommand{\tab}{\hspace{20 mm}}

% part numbering command
\newcounter{partNum}
\newcommand{\partNum}{%
        \stepcounter{partNum}%
        \thepartNum}
\newcommand{\sectPart}[1]{\section*{Part \partNum: #1}}

\newcommand{\bitem}[1]{\item \textbf{#1}}

\newcommand{\assignment}{PreLab 11}
\newcommand{\duedate}{April 18, 2014}
\newcommand{\header}{\noindent \textbf{ECE348 \assignment, Spring 2014 \\
					 Group C1 \\ 
					 Spencer Barton sebarton \\
					 \duedate} \vspace{0.10in} \hrule}

\begin{document}
    
%=======================================================

\header

%=======================================================

\sectPart{Description}

\paragraph*{}
We plan to build an RTOS. We will implement priority ceiling with mutex and a timer to handle periodic tasks. A serial buffer shall act as a shared resource for the mutex. We shall use serial to output details on current tasks and the state of the various tasks. Two interrupts that we will use are swi (for yield) and timer. If we have time we will also implement yield.	

\paragraph*{}
We shall include the following items:
\begin{enumerate}
\item Serial Communications
\item Counter / timer
\item Mutex
\item Priority Ceiling
\item Watchdog
\end{enumerate}

\paragraph*{}
Our interrupts will be:
\begin{enumerate}
\item Timer interrupt
\end{enumerate}

%-----------------------------------------
\sectPart{Requirements}

\begin{enumerate}
\bitem{System Inputs}
	\begin{enumerate}
	\bitem{mutexDisableBtn} Boolean based off of button on board (PB1). When asserted this button disables mutex. Default state is unasserted.
	\bitem{taskEnableBtn[0:2]} Boolean based off of SW[0:2]. When asserted this switch enables a task. When off the task is disabled.
	\end{enumerate}
\bitem{System Outputs}
	\begin{enumerate}
	\bitem{Serial} The Scheduler shall expose internal task state via serial. It shall write to serial after each scheduling event. The format shall be as follows:
\begin{verbatim}
 Task(Default Priority) | Priority | Running | Ready to Run | Scheduled to Run
 -----------------------+----------+---------+--------------+-----------------
 1                      | 1        | false   | true         | false
 3                      | 0        | true    | false        | true
 5                      | 5        | true    | false        | false
\end{verbatim}
	\end{enumerate}
\bitem{State Variables}
	\begin{enumerate}
	\bitem{mutexEnabled} Boolean state variable to keep track of mutex state.
	\end{enumerate}
\bitem{Requirements}
	\begin{enumerate}
	\item When mutexDisableBtn button is pressed the mutex shall be disabled with the mutex enabled otherwise.
	\item When the SWx switch is on task x shall be enabled and when the switch is off task x shall be disabled.
	\item When the scheduler completes execution it shall write the current task state to serial.
	\item The scheduler shall run at least every 100ms.
	\item Buttons shall be polled once per 500 ms to determine which tasks to enable.
	\item The watchdog shall be kicked once per 500 ms.
	\item A task (\texttt{shortBlockTask}) shall run once per 2000 ms for at least 100ms, and shall acquire a mutex for 100ms.
	\item A task (\texttt{longBlockTask}) shall run once per 1900 ms for at least 100ms, and shall acquire a mutex for 300ms.
	\item When \texttt{longBlockTask} and \texttt{shortBlockTask} vie for a mutex and \texttt{longBlockTask} wins, the RTOS shall raise \texttt{longBlockTask}'s priority in order to avoid deadlock.
	\item RTOS shall start with mutexs enabled and shall initialize tasks before running.
	\end{enumerate}
\end{enumerate}

%-----------------------------------------

\sectPart{State Chart}

\includegraphics[scale=.5]{RTOS_State_Chart.pdf}

\sectPart{Requirements/State-Chart Traceability Table}

NOTE: Because we are implementing an RTOS that majority of our requirements relate to RTOS timing and behavior. RTOS state is not easily encapsulated in a state diagram as its state is based on task timing. The state transition diagram relates to the demonstration and peripherals which function as a result of correct RTOS behavior but do not define the RTOS behavior itself.

\vspace*{1em}

\begin{tabular}{c | c | c | c | c | c | c | c | c}
Req. & State 1 & State 2 & State 3 & Trans 1 & Trans 2 & Trans 3 & Trans 4 & Trans 5 \\ \hline
a & - & X & X & - & X & X & X & X \\
b & - & - & - & - & - & - & - & - \\
c & - & X & X & - & - & - & - & - \\
d & - & - & - & - & - & - & - & - \\
e & - & - & - & - & - & - & - & - \\
f & - & - & - & - & - & - & - & - \\
g & - & - & - & - & - & - & - & - \\
h & - & - & - & - & - & - & - & - \\
i & - & - & - & - & - & - & - & - \\
j & X & - & - & X & - & - & - & - \\
\end{tabular}

%-----------------------------------------

\sectPart{Scheduling}

The RTOS shall implement and preemptive multitasking and use this to schedule tasks. It shall use the following priorities and periods:

\vspace{1em}
\begin{tabular}{|l|l|l|p{10em}|p{15em}|}
    \hline
    \textbf{Priority} & \textbf{Task} & \textbf{Period (ms)} & \textbf{Description} & \textbf{Timing Rationale} \\ \hline
    N/A & \texttt{scheduler} & 100 & Schedules other tasks. & N/A \\ \hline
    0 & \texttt{kickWatchdog} & 500 & Kicks COP. & Should run with highest priority to avoid tripping COP. \\ \hline
    1 & \texttt{pollSwitches} & 500 & Polls module SW3 to determine which other tasks to enable. & Should run with higher priority than most tasks it enables/disables. \\ \hline
    2 & \texttt{shortBlockTask} & 2000 & Grabs the same mutex that \texttt{longBlockTask} wants. & Should run infrequently enough that it can be observed visually. \\ \hline
    3 & \texttt{longBlockTask} & 1900 & Grabs the same mutex that \texttt{shortBlockTask} wants. & Should run infrequently enough that it can be observed visually. \\ \hline
\end{tabular}

%-----------------------------------------

\sectPart{Watchdog/COP}

The \texttt{kickWatchdog} task will kick the watchdog timer whenever it runs. We shall set COPCTL\_CR to 0x7, which will require the watchdog to be kicked every 1.048576 seconds (assuming an 8 MHz bus clock). \\
Therefore, the watchdog will trip if the scheduler does not run regularly or fails to respect priorities in such a way that \texttt{kickWatchdog} (priority 0) is not run.

%-----------------------------------------

\sectPart{Test Plan}

\subsection*{Part 7.1: White Box Testing}

NOTE: Key used to simplify table: M is mutexDisableBtn = 1 and ~M is mutexDisableBtn = 0

\vspace*{2em}

\textbf{Tests}\\
\begin{tabular}{c | c | c | c | c | c | c}
Test & Init State & In1 & In2 & In3 & In4 & In5 \\ \hline
1 & 1 & Any(2) & ~M(2) & M(3) & M(3) & ~M(2) \\
\end{tabular}

\vspace*{2em}

\textbf{Traceability} \\
\begin{tabular}{c | c | c | c | c | c}
Test & Trans 1 & Trans 2 & Trans 3 & Trans 4 & Trans 5 \\ \hline
1 & X & X & X & X & X \\
\end{tabular}

\subsection*{Part 7.2: Black Box Testing}

\textbf{Tests}\\
\begin{tabular}{c | c{30em} }
Test & Description \\ \hline
\end{tabular}

\vspace*{2em}

\textbf{Traceability} \\
\begin{tabular}{c | c | c | c | c | c}
Test & Trans 1 & Trans 2 & Trans 3 & Trans 4 & Trans 5 \\ \hline
1 & X & X & X & X & X \\
\end{tabular}

%-----------------------------------------

\sectPart{Hardware}

Our project shall use the following hardware:
\begin{itemize}
    \item MC9S12C128 microcontroller module (including switches and LEDs)
    \item USB cable (for serial communication)
    \item desktop computer
\end{itemize}
This hardware shall be connected as shown here:\\
\vspace{0.25in}
\includegraphics[scale=0.5]{hardware.png}

%-----------------------------------------

\sectPart{Acceptance Test Plan}

Connor

%-----------------------------------------

\section*{Appendix}

	\subsection*{RTOS API}
		TODO
		
%=======================================================

\end{document}
