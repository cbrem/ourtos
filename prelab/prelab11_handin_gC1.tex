\documentclass{article}

\usepackage{color}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{fullpage}


\sloppy
\definecolor{lightgray}{gray}{0.5}
\setlength{\parindent}{0pt}
\renewcommand{\arraystretch}{1.2}

\newcommand{\tab}{\hspace{20 mm}}

% part numbering command
\newcounter{partNum}
\newcommand{\partNum}{%
        \stepcounter{partNum}%
        \thepartNum}
\newcommand{\sectPart}[1]{\section*{Part \partNum: #1}}

\newcommand{\bitem}[1]{\item \textbf{#1}}

\newcommand{\assignment}{PreLab 11}
\newcommand{\duedate}{April 18, 2014}
\newcommand{\header}{\noindent \textbf{ECE348 \assignment, Spring 2014 \\
					 Group C1 \\ 
					 Spencer Barton sebarton \\
					 \duedate} \vspace{0.10in} \hrule}

\begin{document}
    
%=======================================================

\header

%=======================================================

\sectPart{Description}

\paragraph*{}
We plan to build an RTOS. We will implement priority ceiling with mutex and a timer to handle periodic tasks. A serial buffer shall act as a shared resource for the mutex. We shall use serial to output details on current tasks and the state of the various tasks. Two interrupts that we will use are swi (for yield) and timer. If we have time we will also implement yield.	

\paragraph*{}
We shall include the following items:
\begin{enumerate}
\item Serial Communications
\item Counter / timer
\item Mutex
\item Priority Ceiling
\item Watchdog
\end{enumerate}

\paragraph*{}
Our interrupts will be:
\begin{enumerate}
\item Timer interrupt
\end{enumerate}

%-----------------------------------------
\sectPart{Requirements}

\begin{enumerate}
\bitem{System Inputs}
	\begin{enumerate}
	\bitem{mutexDisableBtn} Boolean based off of button on board (PB1). When asserted this button disables mutex. Default state is unasserted.
	\bitem{taskEnableBtn[0:2]} Boolean based off of SW[0:2]. When asserted this switch enables a task. When off the task is disabled.
	\end{enumerate}
\bitem{System Outputs}
	\begin{enumerate}
	\bitem{Serial} The Scheduler shall expose internal task state via serial. It shall write to serial after each scheduling event. The format shall be as follows:
\begin{verbatim}
 Task(Default Priority) | Priority | Running | Ready to Run | Scheduled to Run
 -----------------------+----------+---------+--------------+-----------------
 1                      | 1        | false   | true         | false
 3                      | 0        | true    | false        | true
 5                      | 5        | true    | false        | false
\end{verbatim}
	\end{enumerate}
\bitem{State Variables}
	\begin{enumerate}
	\bitem{mutexEnabled} Boolean state variable to keep track of mutex state.
	\end{enumerate}

\newpage

\bitem{Requirements}
	\begin{enumerate}
	\item When mutexDisableBtn button is pressed the mutex shall be disabled with the mutex enabled otherwise.
	\item When the SWx switch is on task x shall be enabled and when the switch is off task x shall be disabled.
	\item When the scheduler completes execution it shall write the current task state to serial.
	\item The scheduler shall run at least every 100ms.
	\item Buttons shall be polled once per 500 ms to determine which tasks to enable.
	\item The watchdog shall be kicked once per 500 ms.
	\item A task (\texttt{shortBlockTask}) shall run once per 2000 ms for at least 100ms, and shall acquire a mutex for 100ms.
	\item A task (\texttt{longBlockTask}) shall run once per 1900 ms for at least 100ms, and shall acquire a mutex for 300ms.
	\item When \texttt{longBlockTask} and \texttt{shortBlockTask} vie for a mutex and \texttt{longBlockTask} wins, the RTOS shall raise \texttt{longBlockTask}'s priority in order to avoid deadlock.
	\item RTOS shall start with mutexs enabled and shall initialize tasks before running.
	\end{enumerate}
\end{enumerate}

%-----------------------------------------

\sectPart{State Chart}

\begin{center}
    \includegraphics[scale=.5]{RTOS_State_Chart.pdf}
\end{center}

\newpage

\sectPart{Requirements/State-Chart Traceability Table}

NOTE: Because we are implementing an RTOS that majority of our requirements relate to RTOS timing and behavior. RTOS state is not easily encapsulated in a state diagram as its state is based on task timing. The state transition diagram relates to the demonstration and peripherals which function as a result of correct RTOS behavior but do not define the RTOS behavior itself.

\vspace*{1em}

\begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
        \hline
    Req. & State 1 & State 2 & State 3 & Trans 1 & Trans 2 & Trans 3 & Trans 4 & Trans 5 \\ \hline
    a & - & X & X & - & X & X & X & X \\ \hline
    b & - & - & - & - & - & - & - & - \\ \hline
    c & - & X & X & - & - & - & - & - \\ \hline
    d & - & - & - & - & - & - & - & - \\ \hline
    e & - & - & - & - & - & - & - & - \\ \hline
    f & - & - & - & - & - & - & - & - \\ \hline
    g & - & - & - & - & - & - & - & - \\ \hline
    h & - & - & - & - & - & - & - & - \\ \hline
    i & - & - & - & - & - & - & - & - \\ \hline
    j & X & - & - & X & - & - & - & - \\ \hline
    \end{tabular}
\end{center}

%-----------------------------------------

\sectPart{Scheduling}

The RTOS shall implement and preemptive multitasking and use this to schedule tasks. It shall use the following priorities and periods:

\vspace{1em}

\begin{center}
    \begin{tabular}{|l|l|l|p{10em}|p{15em}|}
        \hline
        \textbf{Priority} & \textbf{Task} & \textbf{Period (ms)} & \textbf{Description} & \textbf{Timing Rationale} \\ \hline
        N/A & \texttt{scheduler} & 100 & Schedules other tasks. & N/A \\ \hline
        0 & \texttt{kickWatchdog} & 500 & Kicks COP. & Should run with highest priority to avoid tripping COP. \\ \hline
        1 & \texttt{pollSwitches} & 500 & Polls module SW3 to determine which other tasks to enable. & Should run with higher priority than most tasks it enables/disables. \\ \hline
        2 & \texttt{shortBlockTask} & 2000 & Grabs the same mutex that \texttt{longBlockTask} wants. & Should run infrequently enough that it can be observed visually. \\ \hline
        3 & \texttt{longBlockTask} & 1900 & Grabs the same mutex that \texttt{shortBlockTask} wants. & Should run infrequently enough that it can be observed visually. \\ \hline
    \end{tabular}
\end{center}

%-----------------------------------------

\newpage

\sectPart{Watchdog/COP}

When the \texttt{kickWatchdog} task is enabled, it shall kick the watchdog whenever it is run. We shall set COPCTL\_CR = 0x7, so that the watchdog timer will trip if it is not kicked every 1.048576 seconds (assuming an 8 MHz bus clock). \\
Therefore, the watchdog timer will trip if the \texttt{kickWatchdog} task is not scheduled regularly. This would occur if:
    \begin{itemize}
        \item The \texttt{scheduler} does not run regularly or frequently.
        \item The \texttt{scheduler} fails to respect priorities in such a way that \texttt{kickWatchdog} (priority 0) is not scheduled regularly or frequently.
    \end{itemize}
Therefore, if the watchdog trips, we will know that either \texttt{kickWatchdog} is disabled or the scheduler is functioning incorrectly. \\
If the watchdog trips, the RTOS shall shutdown. Then, the demo shall send a message over serial indicating that the watchdog tripped and restart the RTOS.

%-----------------------------------------

\sectPart{Test Plan}

\subsection*{Part 7.1: White Box Testing}

NOTE: Key used to simplify table: M is mutexDisableBtn = 1 and ~M is mutexDisableBtn = 0

\vspace*{2em}

\begin{center}
    \textbf{Tests}\\
    \begin{tabular}{c | c | c | c | c | c | c}
    Test & Init State & In1 & In2 & In3 & In4 & In5 \\ \hline
    1 & 1 & Any(2) & ~M(2) & M(3) & M(3) & ~M(2) \\
    \end{tabular}
\end{center}

\vspace*{2em}

\begin{center}
    \textbf{Traceability} \\
    \begin{tabular}{c | c | c | c | c | c}
    Test & Trans 1 & Trans 2 & Trans 3 & Trans 4 & Trans 5 \\ \hline
    1 & X & X & X & X & X \\
    \end{tabular}
\end{center}

\subsection*{Part 7.2: Black Box Testing}

\textbf{Tests}\\
\begin{tabular}{c | p{30em} }
Test & Description \\ \hline
1 & Run the RTOS and ensure that serial data is being transmitted to the computer \\
2 & Record the serial transmission in a log file for each of the following tests. Ensure that the data is in the specified format. Check that the log records the RTOS initialization message and that mutexs are enabled. \\
3 & Ensure all the SWx start in the off position. Restart the module and ensure that all tasks are disabled in the serial log. \\
4 & Look at the logs to ensure that the Watchdog triggers after about 1 second. \\
5 & Look at the logs to ensure that the Watchdog event is followed by a software restart. \\
6 & Enable the Watchdog Task and restart the module. Press and hold the \textit{mutexDisable} for 1 second. Check in the log for a line saying the demo is in State 3 and that approximately 1 second later the demo is in State 2. Ensure that the demo is in State 2 for all times when the mutexDisableBtn was not pressed. \\
7 & Enable all tasks and restart the module. Run for 1 minute (use a stopwatch) and record logs. \\
8 & Look at the logs and ensure all time periods are met for all tasks. Ensure that the scheduler is also meeting its timing. Double check the timestamps which should end at 1 minute. \\
9 & Look at the logs and ensure that \texttt{shortBlockTask} and \texttt{longBlockTask} run for the correct duration. \\
10 & Look at the logs and find an instance where \texttt{longBlockTask} changes priority. Ensure that this priority is above the priority of \texttt{shortBlockTask} and that \texttt{shortBlockTask} does not run during the execution of \texttt{longBlockTask}. \\
11 & If yield is implemented examine the log time stamps to ensure that tasks yield control back to the scheduler on completion.
\end{tabular}

\vspace*{2em}

\textbf{Traceability} \\
\begin{tabular}{c | c | c | c | c | c}
Test & Trans 1 & Trans 2 & Trans 3 & Trans 4 & Trans 5 \\ \hline
1 & X & X & X & X & X \\
\end{tabular}

%-----------------------------------------

\sectPart{Hardware}

Our project shall use the following hardware:
\begin{itemize}
    \item MC9S12C128 microcontroller module (including switches and LEDs)
    \item USB cable (for serial communication)
    \item desktop computer
\end{itemize}
This hardware shall be connected as shown here:\\

\begin{center}
    \includegraphics[scale=0.5]{hardware.png}
\end{center}

%-----------------------------------------

\sectPart{Acceptance Test Plan}

Connor

%-----------------------------------------

\section*{Appendix}

	\subsection*{RTOS API}
		
        Users may start and stop the RTOS using:
        \begin{itemize}
            \bitem{\texttt{void rtosStart(void)}}
            \bitem{\texttt{void rtosShutdown(void)}}
        \end{itemize}

        The RTOS will internally represent tasks using the type \texttt{task\_t}. Users may configure the RTOS's task scheduler using:
        \begin{itemize}
            \bitem{\texttt{void rtosSetSchedulerPeriod(uint16\_t period)}}
            \bitem{\texttt{void rtosSetTaskArray(task\_t[] tasks, uint8\_t numTasks)}}
            \bitem{\texttt{void void rtosAddTask(uint8\_t priority, uint16\_t period, void (*task) (void))}}
        \end{itemize}
        These configuration functions should be called before calling \texttt{rtosStart()}. \\


        Additionally, the RTOS will provide a mutex implementation. Mutexs will have type \texttt{mutex\_t}. The RTOS will support the following functions for mutexes:
        \begin{itemize}
            \bitem{\texttt{rtosAddMutex(uint8\_t priority, mutex\_t *mutex)}}
            \bitem{\texttt{rtosAcquireMutex(mutex\_t *mutex)}}
            \bitem{\texttt{rtosReleaseMutex(mutex\_t *mutex)}}
        \end{itemize}

        Finally, the user may enable and disable various features and tasks while the RTOS is running using the following methods:
        \begin{itemize}
            \bitem{\texttt{void rtosEnableDebug(bool\_t enable)}}
            \bitem{\texttt{void rtosEnableMutexes(bool\_t enable)}}
            \bitem{\texttt{void rtosEnableTask(bool\_t enable)}}
        \end{itemize}
		
%=======================================================

\end{document}
